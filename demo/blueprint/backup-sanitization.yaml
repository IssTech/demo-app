apiVersion: cr.kanister.io/v1alpha1
kind: Blueprint
metadata:
  name: postgres-non-exclusive-backup
  namespace: kasten-io
actions:
  backupPrehook:
    kind: StatefulSet
    phases:
    - name: createBackupSessionPod
      func: KubeOps
      objects:
        pgSecret:
          kind: Secret
          name: '{{ index .Object.metadata.labels "app.kubernetes.io/instance"}}-postgresql'
          namespace: '{{ .StatefulSet.Namespace }}'
      args:
        operation: create
        namespace: '{{ .StatefulSet.Namespace }}'
        spec: |-
          apiVersion: v1
          kind: Pod
          metadata:
            name: {{ .StatefulSet.Name }}-backup-session
          spec:
            restartPolicy: Never
            containers:
              - name: container
                image: postgres:17
                resources:
                  requests:
                    memory: "512Mi"
                    cpu: "500m"
                  limits:
                    memory: "4Gi"
                    cpu: "1"
                command:
                - bash
                - -o
                - errexit
                - -o
                - pipefail
                - -c
                - |
                  export PGHOST_OLD='{{ index .Object.metadata.labels "app.kubernetes.io/instance" }}-postgresql.{{ .StatefulSet.Namespace }}.svc.cluster.local'
                  export PGHOST='{{ index .Object.metadata.labels "kanister.io/serviceName" }}.{{ .StatefulSet.Namespace }}.svc.cluster.local'
                  export PGUSER='{{ index .Phases.createBackupSessionPod.Secrets.pgSecret.Data "POSTGRES_USER" | toString }}'
                  export PGPASSWORD='{{ index .Phases.createBackupSessionPod.Secrets.pgSecret.Data "POSTGRES_PASSWORD" | toString }}'
                  ## Create file descriptor to send commands to psql
                  mkfifo /tmp/pg_in
                  ## Create "holder" process to keep pg_in open
                  while sleep 1; do :; done >/tmp/pg_in &
                  ## Save "holder" PID to a file to kill it later
                  echo $! > /tmp/holder_pid
                  ## Run psql session reading from pg_in and writing ot pg_out
                  ## Using tee here to keep the pod logs (might need to replace with just `> /tmp/pg_out`)
                  ## TODO: should we track stderr here?
                  echo ############################
                  echo $PGHOST
                  echo ############################
                  echo $PGHOST_OLD
                  echo ############################
                  cat /tmp/pg_in | psql -h $PGHOST -U $PGUSER | tee /tmp/pg_out
    - func: WaitV2
      name: waitBackupSessionPodReady
      args:
        timeout: 5m
        conditions:
          anyOf:
          - condition: '{{ $available := false }}{{ range $condition := $.status.conditions }}{{ if and (eq .type "ContainersReady") (eq .status "True") }}{{ $available = true }}{{ end }}{{ end }}{{ $available }}'
            objectReference:
              apiVersion: "v1"
              name: "{{ .StatefulSet.Name }}-backup-session"
              namespace: '{{ .StatefulSet.Namespace }}'
              resource: "pods"
    - name: startBackupSession
      func: KubeExec
      args:
        namespace: '{{ .StatefulSet.Namespace }}'
        pod: "{{ .StatefulSet.Name }}-backup-session"
        command:
        - bash
        - -o
        - errexit
        - -o
        - pipefail
        - -c
        - |
          ## Send pg_backup_start command to psql session
          echo "SELECT pg_backup_start(label => 'kanister_backup', fast => false);" > /tmp/pg_in
          ## Make sure operation completed
          ## TODO: maybe there's a better way to fail/log here?
          grep -q pg_backup_start <(tail -f /tmp/pg_out)

  backupPosthook:
    kind: StatefulSet
    phases:
    - name: stopBackupSession
      func: KubeExec
      args:
        namespace: '{{ .StatefulSet.Namespace }}'
        pod: "{{ .StatefulSet.Name }}-backup-session"
        command:
        - bash
        - -o
        - errexit
        - -o
        - pipefail
        - -c
        - |
          ## Send pg_backup_stop command to psql session
          echo "SELECT * FROM pg_backup_stop(wait_for_archive => true);" > /tmp/pg_in
          ## Make sure operation completed
          ## TODO: maybe there's a better way to fail/log here?
          grep -q "LABEL: kanister_backup" <(tail -f /tmp/pg_out)
    - name: deleteBackupPodSession
      func: KubeOps
      args:
        operation: delete
        objectReference:
          apiVersion: v1
          resource: "pods"
          name: "{{ .StatefulSet.Name }}-backup-session"
          namespace: '{{ .StatefulSet.Namespace }}'

  dataSanitization:
    kind: StatefulSet
    phases:
    - name: createSanditySessionPod
      func: KubeOps
      args:
        operation: create
        namespace: '{{ .Object.metadata.name }}'
        spec: |-
          apiVersion: v1
          kind: Pod
          metadata:
            name: postgres-sanity-session
            namespace: '{{ .Object.metadata.name }}'
          spec:
            restartPolicy: Never
            containers:
              - name: container
                image: postgres:17
                pullPolicy: IfNotPresent
                env:
                  - name: PGUSER
                    valueFrom:
                      secretKeyRef:
                        name: postgres-postgresql
                        key: POSTGRES_USER
                  - name: PGPASSWORD
                    valueFrom:
                      secretKeyRef:
                        name: postgres-postgresql
                        key: POSTGRES_PASSWORD
                command:
                - bash
                - -o
                - errexit
                - -o
                - pipefail
                - -c
                - |
                  echo "--- STARTING SANITIZATION ---"

                  # We use 'postgres-postgresql' as the service name based on your secret's connection string
                  export PGHOST="postgres-postgresql.{{ .Object.metadata.name }}.svc.cluster.local"
                  
                  echo "Target Namespace: {{ .Object.metadata.name }}"
                  echo "Target Host: $PGHOST"
                  echo "Target User: $PGUSER"
                  
                  export SQL_COMMAND="WITH new_firstnames AS (SELECT id, ROW_NUMBER() OVER (ORDER BY id) AS rn, 'AAAAA-' || LEFT(MD5(ROW_NUMBER() OVER (ORDER BY id)::text), 5) || '-' || ROW_NUMBER() OVER (ORDER BY id)::text AS new_value FROM users) UPDATE users AS u SET firstname = n.new_value FROM new_firstnames AS n WHERE u.id = n.id;"
                  
                  echo "Executing SQL update..."
                  psql -h $PGHOST -U $PGUSER -d demo_app_db -c "$SQL_COMMAND"
                  
                  echo "--- COMPLETED ---"

    - name: waitSanitizationComplete
      func: WaitV2
      args:
        timeout: 5m
        conditions:
          anyOf:
            - condition: '{{ eq .status.phase "Succeeded" }}'
              objectReference:
                apiVersion: v1
                resource: pods
                name: "postgres-sanity-session"
                namespace: '{{ .Object.metadata.name }}'

    - name: deleteSanityPodSession
      func: KubeOps
      args:
        operation: delete
        objectReference:
          apiVersion: v1
          resource: "pods"
          name: "postgres-sanity-session"
          namespace: '{{ .Object.metadata.name }}'